const path = require('path');
const fs = require('fs');
const { app } = require('electron');
const MemoryDatabaseService = require('./memory-database');

// Essayer de charger better-sqlite3, utiliser le fallback si √©chec
let Database = null;
try {
  Database = require('better-sqlite3');
  console.log('‚úÖ better-sqlite3 charg√© avec succ√®s');
} catch (error) {
  console.warn('‚ö†Ô∏è better-sqlite3 non disponible:', error.message);
  console.log('üîÑ Utilisation du mode m√©moire comme fallback');
}

class DatabaseService {
  constructor() {
    this.db = null;
    this.dbPath = null;
    this.isInitialized = false;
    this.useMemoryFallback = !Database; // Si SQLite n'est pas disponible
    this.memoryDb = null;
  }

  async initialize() {
    if (this.isInitialized) return;

    try {
      if (this.useMemoryFallback) {
        console.log('üìù Initialisation en mode m√©moire (SQLite indisponible)');
        this.memoryDb = new MemoryDatabaseService();
        await this.memoryDb.initialize();
        this.isInitialized = true;
        console.log('‚úÖ Base de donn√©es en m√©moire initialis√©e');
        return;
      }

      // Mode SQLite normal
      const userDataPath = app.getPath('userData');
      if (!fs.existsSync(userDataPath)) {
        fs.mkdirSync(userDataPath, { recursive: true });
      }

      this.dbPath = path.join(userDataPath, 'evaluation_system.db');
      console.log('Initialisation de la base de donn√©es SQLite:', this.dbPath);

      this.db = new Database(this.dbPath, { 
        verbose: console.log,
        fileMustExist: false 
      });

      // Activer les cl√©s √©trang√®res et les optimisations
      this.db.pragma('journal_mode = WAL');
      this.db.pragma('synchronous = NORMAL');
      this.db.pragma('cache_size = 10000');
      this.db.pragma('foreign_keys = ON');

      await this.createTables();
      this.isInitialized = true;
      console.log('‚úÖ Base de donn√©es SQLite initialis√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur initialisation base de donn√©es:', error);
      throw error;
    }
  }

  async createTables() {
    const tables = [
      // Table des utilisateurs
      `CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        firstName TEXT NOT NULL,
        lastName TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        role TEXT DEFAULT 'user',
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,

      // Table du personnel
      `CREATE TABLE IF NOT EXISTS staff (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        matricule TEXT UNIQUE,
        firstName TEXT NOT NULL,
        lastName TEXT NOT NULL,
        position TEXT,
        email TEXT UNIQUE,
        phone TEXT,
        establishment TEXT,
        formationYear INTEGER,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,

      // Table des th√®mes de formation
      `CREATE TABLE IF NOT EXISTS themes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP
      )`,

      // Table des √©valuations
      `CREATE TABLE IF NOT EXISTS evaluations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        staffId INTEGER,
        firstName TEXT,
        lastName TEXT,
        fillDate TEXT,
        formationTheme TEXT,
        skillsAcquisition INTEGER,
        personalDevelopment INTEGER,
        courseClarity INTEGER,
        theoryPractice INTEGER,
        syllabusAdequacy INTEGER,
        practicalCases INTEGER,
        objectivesAchieved INTEGER,
        adaptedKnowledge INTEGER,
        pedagogicalSupport INTEGER,
        techniquesUsed INTEGER,
        presentation INTEGER,
        logisticsConditions INTEGER,
        rhythm INTEGER,
        punctuality INTEGER,
        punctualityAssiduity INTEGER,
        teamworkSense INTEGER,
        motivationEnthusiasm INTEGER,
        communicationSociable INTEGER,
        communicationGeneral INTEGER,
        aptitudeChangeIdeas INTEGER,
        curiosity INTEGER,
        initiativeSpirit INTEGER,
        responsibilitySense INTEGER,
        criticalAnalysis INTEGER,
        workExecution INTEGER,
        directivesComprehension INTEGER,
        workQuality INTEGER,
        subjectMastery INTEGER,
        recommendationScore INTEGER,
        justificationObservations TEXT,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
        updatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (staffId) REFERENCES staff(id) ON DELETE CASCADE
      )`
    ];

    // Cr√©er les tables une par une de mani√®re asynchrone
    for (const table of tables) {
      try {
        this.db.exec(table);
      } catch (error) {
        console.error('Erreur cr√©ation table:', error);
      }
    }

    // Ins√©rer des th√®mes par d√©faut s'ils n'existent pas
    const themeCount = this.db.prepare('SELECT COUNT(*) as count FROM themes').get().count;
    if (themeCount === 0) {
      const defaultThemes = [
        { name: 'Leadership Management', description: 'Formation sur les techniques de leadership et de management d\'√©quipe' },
        { name: 'Communication Efficace', description: 'Am√©liorer ses comp√©tences en communication interpersonnelle' },
        { name: 'Gestion de Projet', description: 'M√©thodologies et outils pour la gestion de projets' },
        { name: 'Innovation & Cr√©ativit√©', description: 'D√©velopper l\'innovation et la cr√©ativit√© en entreprise' }
      ];

      const insertTheme = this.db.prepare('INSERT INTO themes (name, description) VALUES (?, ?)');
      const insertMany = this.db.transaction((themes) => {
        for (const theme of themes) {
          insertTheme.run(theme.name, theme.description);
        }
      });

      insertMany(defaultThemes);
      console.log('Th√®mes par d√©faut cr√©√©s');
    }
  }

  // M√©thode helper pour d√©l√©guer selon le mode
  _delegate(method, ...args) {
    if (this.useMemoryFallback) {
      return this.memoryDb[method](...args);
    }
    // Utiliser la m√©thode SQLite existante
    return this[`_sqlite_${method}`](...args);
  }

  // M√©thodes unifi√©es avec d√©l√©gation automatique
  
  // Users
  async getUsers() {
    if (this.useMemoryFallback) return this.memoryDb.getUsers();
    try {
      const stmt = this.db.prepare('SELECT * FROM users ORDER BY createdAt DESC');
      return stmt.all();
    } catch (error) {
      console.error('Erreur getUsers:', error);
      return [];
    }
  }

  async createUser(userData) {
    if (this.useMemoryFallback) return this.memoryDb.createUser(userData);
    return this._sqlite_createUser(userData);
  }

  async updateUser(id, userData) {
    if (this.useMemoryFallback) return this.memoryDb.updateUser(id, userData);
    return this._sqlite_updateUser(id, userData);
  }

  async deleteUser(id) {
    if (this.useMemoryFallback) return this.memoryDb.deleteUser(id);
    return this._sqlite_deleteUser(id);
  }

  // Staff
  async getStaff() {
    if (this.useMemoryFallback) return this.memoryDb.getStaff();
    return this._sqlite_getStaff();
  }

  async createStaff(staffData) {
    if (this.useMemoryFallback) return this.memoryDb.createStaff(staffData);
    return this._sqlite_createStaff(staffData);
  }

  async updateStaff(id, staffData) {
    if (this.useMemoryFallback) return this.memoryDb.updateStaff(id, staffData);
    return this._sqlite_updateStaff(id, staffData);
  }

  async deleteStaff(id) {
    if (this.useMemoryFallback) return this.memoryDb.deleteStaff(id);
    return this._sqlite_deleteStaff(id);
  }

  // Themes
  async getThemes() {
    if (this.useMemoryFallback) return this.memoryDb.getThemes();
    return this._sqlite_getThemes();
  }

  async createTheme(themeData) {
    if (this.useMemoryFallback) return this.memoryDb.createTheme(themeData);
    return this._sqlite_createTheme(themeData);
  }

  async updateTheme(id, themeData) {
    if (this.useMemoryFallback) return this.memoryDb.updateTheme(id, themeData);
    return this._sqlite_updateTheme(id, themeData);
  }

  async deleteTheme(id) {
    if (this.useMemoryFallback) return this.memoryDb.deleteTheme(id);
    return this._sqlite_deleteTheme(id);
  }

  // Evaluations
  async getEvaluations() {
    if (this.useMemoryFallback) return this.memoryDb.getEvaluations();
    return this._sqlite_getEvaluations();
  }

  async createEvaluation(evaluationData) {
    if (this.useMemoryFallback) return this.memoryDb.createEvaluation(evaluationData);
    return this._sqlite_createEvaluation(evaluationData);
  }

  async updateEvaluation(id, evaluationData) {
    if (this.useMemoryFallback) return this.memoryDb.updateEvaluation(id, evaluationData);
    return this._sqlite_updateEvaluation(id, evaluationData);
  }

  async deleteEvaluation(id) {
    if (this.useMemoryFallback) return this.memoryDb.deleteEvaluation(id);
    return this._sqlite_deleteEvaluation(id);
  }

  async getEvaluationStats() {
    if (this.useMemoryFallback) return this.memoryDb.getEvaluationStats();
    return this._sqlite_getEvaluationStats();
  }

  async exportData(type) {
    if (this.useMemoryFallback) return this.memoryDb.exportData(type);
    return this._sqlite_exportData(type);
  }

  async importData(jsonData) {
    if (this.useMemoryFallback) return this.memoryDb.importData(jsonData);
    return this._sqlite_importData(jsonData);
  }

  close() {
    if (this.useMemoryFallback) {
      this.memoryDb.close();
    } else if (this.db) {
      this.db.close();
    }
  }

}

// Instance singleton
const databaseService = new DatabaseService();

module.exports = databaseService;
